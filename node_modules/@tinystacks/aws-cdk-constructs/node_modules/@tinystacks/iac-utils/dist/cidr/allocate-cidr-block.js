"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allocateCidrBlock = void 0;
const prando_1 = __importDefault(require("prando"));
function constructCidr(intHash, args) {
    const { prefix: inputPrefix, networkMask, seed } = args;
    const addressCount = Math.pow(2, (32 - networkMask));
    let intHashPosition = 1;
    if (addressCount <= 256) {
        intHashPosition = 3;
    }
    else if (addressCount > 256 && addressCount < 65536) {
        intHashPosition = 2;
    }
    const prefixElems = inputPrefix.split('.');
    prefixElems[intHashPosition] = intHash.toString();
    const prefix = prefixElems.join('.');
    const cidrBlock = [prefix, networkMask].join('/');
    return {
        cidrBlock,
        networkMask,
        prefix,
        seed
    };
}
function isIPv4(ip) {
    const octets = ip.split('.');
    const hasFourOctets = octets.length === 4;
    const eachOctetIs8Bit = octets.reduce((acc, octet) => {
        const numOctet = Number(octet);
        const octetIs8Bit = !Number.isNaN(numOctet) && numOctet >= 0 && numOctet <= 255;
        acc = acc && octetIs8Bit;
        return acc;
    }, true);
    return hasFourOctets && eachOctetIs8Bit;
}
function isValidNetworkMask(networkMask) {
    return networkMask >= 8 && networkMask <= 32;
}
function validateArguments(args) {
    const { seed, prefix = '10.0.0.0', networkMask = 16, exclusions = [] } = args;
    if (!seed || typeof seed !== 'string' || seed?.length < 1) {
        throw new Error(`Invalid value: ${seed}; "seed" argument must be a string with length greater than zero!`);
    }
    if (!isIPv4(prefix)) {
        throw new Error(`Invalid value: ${prefix}; "prefix" argument must be a valid IPv4 address!`);
    }
    if (!isValidNetworkMask(networkMask)) {
        throw new Error(`Invalid value: ${networkMask}; "networkMask" argument must be an integer between 8 and 32!`);
    }
    for (const exclusion of exclusions) {
        const [exclusionPrefix, exclusionNetworkMask] = exclusion.split('/');
        if (!isIPv4(exclusionPrefix) || !isValidNetworkMask(Number(exclusionNetworkMask))) {
            throw new Error(`Invalid exclusion value: ${exclusion}; an exclusion must be a valid IPv4 CIDR Block!`);
        }
    }
    return {
        seed,
        prefix,
        networkMask,
        exclusions
    };
}
function generateCidrBlock(rng, args) {
    const { exclusions } = args;
    const intHash = rng.nextInt(0, 255);
    const cidrBlockAllocation = constructCidr(intHash, args);
    if (exclusions?.includes(cidrBlockAllocation.cidrBlock))
        return generateCidrBlock(rng, args);
    return cidrBlockAllocation;
}
/**
 * Deterministically generate a CIDR block range.
 *
 * @remarks
 * Given the same inputs, it will generate the same output.
 * This can be useful if you need to create mutiple VPCs that need to be peered since peered VPCs cannot have overlapping CIDR ranges.
 *
 * @param args - {@link AllocateCidrBlockArguments}
 * @returns CidrBlockAllocation - {@link CidrBlockAllocation}
 */
function allocateCidrBlock(args) {
    const validatedArguments = validateArguments(args);
    const rng = new prando_1.default(validatedArguments.seed);
    return generateCidrBlock(rng, validatedArguments);
}
exports.allocateCidrBlock = allocateCidrBlock;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxsb2NhdGUtY2lkci1ibG9jay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaWRyL2FsbG9jYXRlLWNpZHItYmxvY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0RBQTRCO0FBOEU1QixTQUFTLGFBQWEsQ0FBRSxPQUFlLEVBQUUsSUFBeUM7SUFDaEYsTUFBTSxFQUNKLE1BQU0sRUFBRSxXQUFXLEVBQ25CLFdBQVcsRUFDWCxJQUFJLEVBQ0wsR0FBRyxJQUFJLENBQUM7SUFFVCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ3JELElBQUksZUFBZSxHQUFHLENBQUMsQ0FBQztJQUN4QixJQUFJLFlBQVksSUFBSSxHQUFHLEVBQUU7UUFDdkIsZUFBZSxHQUFHLENBQUMsQ0FBQztLQUNyQjtTQUFNLElBQUksWUFBWSxHQUFHLEdBQUcsSUFBSSxZQUFZLEdBQUcsS0FBSyxFQUFFO1FBQ3JELGVBQWUsR0FBRyxDQUFDLENBQUM7S0FDckI7SUFFRCxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNDLFdBQVcsQ0FBQyxlQUFlLENBQUMsR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEQsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxNQUFNLFNBQVMsR0FBRyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEQsT0FBTztRQUNMLFNBQVM7UUFDVCxXQUFXO1FBQ1gsTUFBTTtRQUNOLElBQUk7S0FDTCxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsTUFBTSxDQUFFLEVBQVU7SUFDekIsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLEtBQUss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QUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hELE9BQU8saUJBQWlCLENBQUMsR0FBRyxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUdDLDhDQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcmFuZG8gZnJvbSAncHJhbmRvJztcblxuLyoqXG4gKiBSZXR1cm4gdmFsdWUgZm9yIGFsbG9jYXRlQ2lkckJsb2NrLlxuICovXG5pbnRlcmZhY2UgQ2lkckJsb2NrQWxsb2NhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgQ0lEUiByYW5nZSB0aGF0IHdhcyBnZW5lcmF0ZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIDEwLjAuMC4wLzE2XG4gICAqL1xuICBjaWRyQmxvY2s6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBzZWVkIHVzZWQgdG8gZ2VuZXJhdGUgdGhpcyBDSURSIGJsb2NrLlxuICAgKi9cbiAgc2VlZDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIElQIHByZWZpeCBvZiB0aGUgQ0lEUiByYW5nZSAoSVB2NCBhZGRyZXNzIG9mIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UpLlxuICAgKiBAZXhhbXBsZVxuICAgKiAxMC4wLjAuMFxuICAgKi9cbiAgcHJlZml4OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmV0d29yayBtYXNrIG9mIHRoZSBDSURSIHJhbmdlIChpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgdGhlIENJRFIgYmxvY2spLlxuICAgKiBAZXhhbXBsZVxuICAgKiAxNlxuICAgKi9cbiAgbmV0d29ya01hc2s6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIGdlbmVyYXRpbmcgYSBDSURSIGJsb2NrLlxuICovXG5pbnRlcmZhY2UgQWxsb2NhdGVDaWRyQmxvY2tBcmd1bWVudHMge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gYmUgdXNlZCBhcyBhIHNlZWQgZm9yIHRoZSBDSURSIGdlbmVyYXRpb24uXG4gICAqIFxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBhbGwgb3RoZXIgaW5wdXRzIGFyZSB0aGUgc2FtZSwgdHdvIGRpZmZlcmVudCBzZWVkcyBoYXZlIGEgMSBpbiAyNTYgY2hhbmNlIG9mIGJlaW5nIGR1cGxpY2F0ZXMuXG4gICAqIElmIHlvdSBhcmUgZ2VuZXJhdGluZyBtdWx0aXBsZSBDSURSIGJsb2NrcyBhbmQgbmVlZCB0aGVtIHRvIGJlIHVuaXF1ZSwgZ2VuZXJhdGUgdGhlbSBpbiBzZXF1ZW5jZSBwcm92aWRpbmcgcHJldmlvdXNseSBnZW5lcmF0ZWQgYmxvY2tzIGluIHRoZSB7QGxpbmsgZXhjbHVzaW9uc30gYXJndW1lbnQuXG4gICAqL1xuICBzZWVkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbiBJUHY0IHByZWZpeCBmb3IgdGhlIENJRFIgYmxvY2sgdG8gdXNlIGFzIGEgYmFzZS5cbiAgICogXG4gICAqIEByZW1hcmtzXG4gICAqIERlcGVuZGluZyBvbiB0aGUgbmV0d29yayBtYXNrLCBvbmUgb2YgdGhlIG9jdGV0cyB3aWxsIGxpa2VseSBiZSByZXBsYWNlZC5cbiAgICogVGhpcyBzaG91bGQgdHlwaWNhbGx5IGJlIGZyb20gdGhlIFByaXZhdGUgQWRkcmVzcyBTcGFjZSBkZWZpbmVkIGluIFJGQyAxOTE4IHtAbGluayBodHRwOi8vd3d3LmZhcXMub3JnL3JmY3MvcmZjMTkxOC5odG1sfVxuICAgKiBcbiAgICogQGRlZmF1bHRWYWx1ZSAxMC4wLjAuMFxuICAgKi9cbiAgcHJlZml4Pzogc3RyaW5nO1xuICAvKipcbiAgICogQW4gaW50ZWdlciBiZXR3ZWVuIDggYW5kIDMyXG4gICAqIFxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIHZhbHVlIHdpbGwgZGV0ZXJtaW5lIGhvdyBtYW55IElQIGFkZHJlc3NlcyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB5b3VyIENJRFIgYmxvY2suXG4gICAqIFxuICAgKiBAZGVmYXVsdFZhbHVlIDE2XG4gICAqL1xuICBuZXR3b3JrTWFzaz86IG51bWJlcjtcbiAgLyoqXG4gICAqIENJRFIgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdHMuXG4gICAqIFxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiB0aGUgQ0lEUiBibG9jayBnZW5lcmF0ZWQgbWF0Y2hlcyBhbnkgb2YgdGhlIHZhbHVlcyBwcm92aWRlZCBoZXJlLCB0aGUgbWV0aG9kIHdpbGwgcmUtZ2VuZXJhdGUgYW5kIHJlLWNoZWNrIGFnYWluc3QgdGhpcyBsaXN0IHVudGlsIGl0IHJ1bnMgb3V0IG9mIG9wdGlvbnMuXG4gICAqIE5vdGUgdGhhdCBmb3IgYSBnaXZlbiBwcmVmaXggYW5kIG5ldHdvcmsgbWFzaywgb25seSAyNTYgdW5pcXVlIENJRFIgYmxvY2tzIGNhbiBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICBleGNsdXNpb25zPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBWYWxpZGF0ZWRBbGxvY2F0ZUNpZHJCbG9ja0FyZ3VtZW50cyB7XG4gIHNlZWQ6IHN0cmluZztcbiAgcHJlZml4OiBzdHJpbmc7XG4gIG5ldHdvcmtNYXNrOiBudW1iZXI7XG4gIGV4Y2x1c2lvbnM6IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDaWRyIChpbnRIYXNoOiBudW1iZXIsIGFyZ3M6IFZhbGlkYXRlZEFsbG9jYXRlQ2lkckJsb2NrQXJndW1lbnRzKTogQ2lkckJsb2NrQWxsb2NhdGlvbiB7XG4gIGNvbnN0IHtcbiAgICBwcmVmaXg6IGlucHV0UHJlZml4LFxuICAgIG5ldHdvcmtNYXNrLFxuICAgIHNlZWRcbiAgfSA9IGFyZ3M7XG5cbiAgY29uc3QgYWRkcmVzc0NvdW50ID0gTWF0aC5wb3coMiwgKDMyIC0gbmV0d29ya01hc2spKTtcbiAgbGV0IGludEhhc2hQb3NpdGlvbiA9IDE7XG4gIGlmIChhZGRyZXNzQ291bnQgPD0gMjU2KSB7XG4gICAgaW50SGFzaFBvc2l0aW9uID0gMztcbiAgfSBlbHNlIGlmIChhZGRyZXNzQ291bnQgPiAyNTYgJiYgYWRkcmVzc0NvdW50IDwgNjU1MzYpIHtcbiAgICBpbnRIYXNoUG9zaXRpb24gPSAyO1xuICB9XG5cbiAgY29uc3QgcHJlZml4RWxlbXMgPSBpbnB1dFByZWZpeC5zcGxpdCgnLicpO1xuICBwcmVmaXhFbGVtc1tpbnRIYXNoUG9zaXRpb25dID0gaW50SGFzaC50b1N0cmluZygpO1xuICBjb25zdCBwcmVmaXggPSBwcmVmaXhFbGVtcy5qb2luKCcuJyk7XG4gIGNvbnN0IGNpZHJCbG9jayA9IFtwcmVmaXgsIG5ldHdvcmtNYXNrXS5qb2luKCcvJyk7XG4gIHJldHVybiB7XG4gICAgY2lkckJsb2NrLFxuICAgIG5ldHdvcmtNYXNrLFxuICAgIHByZWZpeCxcbiAgICBzZWVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzSVB2NCAoaXA6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBvY3RldHMgPSBpcC5zcGxpdCgnLicpO1xuICBjb25zdCBoYXNGb3VyT2N0ZXRzID0gb2N0ZXRzLmxlbmd0aCA9PT0gNDtcbiAgY29uc3QgZWFjaE9jdGV0SXM4Qml0ID0gb2N0ZXRzLnJlZHVjZTxib29sZWFuPigoYWNjLCBvY3RldDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbnVtT2N0ZXQgPSBOdW1iZXIob2N0ZXQpO1xuICAgIGNvbnN0IG9jdGV0SXM4Qml0ID0gIU51bWJlci5pc05hTihudW1PY3RldCkgJiYgbnVtT2N0ZXQgPj0gMCAmJiBudW1PY3RldCA8PSAyNTU7XG4gICAgYWNjID0gYWNjICYmIG9jdGV0SXM4Qml0O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHRydWUpO1xuICByZXR1cm4gaGFzRm91ck9jdGV0cyAmJiBlYWNoT2N0ZXRJczhCaXQ7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWROZXR3b3JrTWFzayAobmV0d29ya01hc2s6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gbmV0d29ya01hc2sgPj0gOCAmJiBuZXR3b3JrTWFzayA8PSAzMjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBcmd1bWVudHMgKGFyZ3M6IEFsbG9jYXRlQ2lkckJsb2NrQXJndW1lbnRzKTogVmFsaWRhdGVkQWxsb2NhdGVDaWRyQmxvY2tBcmd1bWVudHMge1xuICBjb25zdCB7XG4gICAgc2VlZCxcbiAgICBwcmVmaXggPSAnMTAuMC4wLjAnLFxuICAgIG5ldHdvcmtNYXNrID0gMTYsXG4gICAgZXhjbHVzaW9ucyA9IFtdXG4gIH0gPSBhcmdzO1xuICBpZiAoIXNlZWQgfHwgdHlwZW9mIHNlZWQgIT09ICdzdHJpbmcnIHx8IHNlZWQ/Lmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWU6ICR7c2VlZH07IFwic2VlZFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgd2l0aCBsZW5ndGggZ3JlYXRlciB0aGFuIHplcm8hYCk7XG4gIH1cbiAgaWYgKCFpc0lQdjQocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZTogJHtwcmVmaXh9OyBcInByZWZpeFwiIGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBJUHY0IGFkZHJlc3MhYCk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkTmV0d29ya01hc2sobmV0d29ya01hc2spKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlOiAke25ldHdvcmtNYXNrfTsgXCJuZXR3b3JrTWFza1wiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDggYW5kIDMyIWApO1xuICB9XG4gIGZvciAoY29uc3QgZXhjbHVzaW9uIG9mIGV4Y2x1c2lvbnMpIHtcbiAgICBjb25zdCBbZXhjbHVzaW9uUHJlZml4LCBleGNsdXNpb25OZXR3b3JrTWFza10gPSBleGNsdXNpb24uc3BsaXQoJy8nKTtcbiAgICBpZiAoIWlzSVB2NChleGNsdXNpb25QcmVmaXgpIHx8ICFpc1ZhbGlkTmV0d29ya01hc2soTnVtYmVyKGV4Y2x1c2lvbk5ldHdvcmtNYXNrKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleGNsdXNpb24gdmFsdWU6ICR7ZXhjbHVzaW9ufTsgYW4gZXhjbHVzaW9uIG11c3QgYmUgYSB2YWxpZCBJUHY0IENJRFIgQmxvY2shYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZWVkLFxuICAgIHByZWZpeCxcbiAgICBuZXR3b3JrTWFzayxcbiAgICBleGNsdXNpb25zXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2lkckJsb2NrIChybmc6IFByYW5kbywgYXJnczogVmFsaWRhdGVkQWxsb2NhdGVDaWRyQmxvY2tBcmd1bWVudHMpOiBDaWRyQmxvY2tBbGxvY2F0aW9uIHtcbiAgY29uc3Qge1xuICAgIGV4Y2x1c2lvbnNcbiAgfSA9IGFyZ3M7XG4gIGNvbnN0IGludEhhc2ggPSBybmcubmV4dEludCgwLCAyNTUpO1xuICBjb25zdCBjaWRyQmxvY2tBbGxvY2F0aW9uID0gY29uc3RydWN0Q2lkcihpbnRIYXNoLCBhcmdzKTtcbiAgaWYgKGV4Y2x1c2lvbnM/LmluY2x1ZGVzKGNpZHJCbG9ja0FsbG9jYXRpb24uY2lkckJsb2NrKSkgcmV0dXJuIGdlbmVyYXRlQ2lkckJsb2NrKHJuZywgYXJncyk7XG4gIHJldHVybiBjaWRyQmxvY2tBbGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIERldGVybWluaXN0aWNhbGx5IGdlbmVyYXRlIGEgQ0lEUiBibG9jayByYW5nZS5cbiAqIFxuICogQHJlbWFya3NcbiAqIEdpdmVuIHRoZSBzYW1lIGlucHV0cywgaXQgd2lsbCBnZW5lcmF0ZSB0aGUgc2FtZSBvdXRwdXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gY3JlYXRlIG11dGlwbGUgVlBDcyB0aGF0IG5lZWQgdG8gYmUgcGVlcmVkIHNpbmNlIHBlZXJlZCBWUENzIGNhbm5vdCBoYXZlIG92ZXJsYXBwaW5nIENJRFIgcmFuZ2VzLlxuICogXG4gKiBAcGFyYW0gYXJncyAtIHtAbGluayBBbGxvY2F0ZUNpZHJCbG9ja0FyZ3VtZW50c31cbiAqIEByZXR1cm5zIENpZHJCbG9ja0FsbG9jYXRpb24gLSB7QGxpbmsgQ2lkckJsb2NrQWxsb2NhdGlvbn1cbiAqL1xuZnVuY3Rpb24gYWxsb2NhdGVDaWRyQmxvY2sgKGFyZ3M6IEFsbG9jYXRlQ2lkckJsb2NrQXJndW1lbnRzKTogQ2lkckJsb2NrQWxsb2NhdGlvbiB7XG4gIGNvbnN0IHZhbGlkYXRlZEFyZ3VtZW50cyA9IHZhbGlkYXRlQXJndW1lbnRzKGFyZ3MpO1xuICBjb25zdCBybmcgPSBuZXcgUHJhbmRvKHZhbGlkYXRlZEFyZ3VtZW50cy5zZWVkKTtcbiAgcmV0dXJuIGdlbmVyYXRlQ2lkckJsb2NrKHJuZywgdmFsaWRhdGVkQXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IHtcbiAgYWxsb2NhdGVDaWRyQmxvY2ssXG4gIENpZHJCbG9ja0FsbG9jYXRpb25cbn07Il19