/**
 * Return value for allocateCidrBlock.
 */
interface CidrBlockAllocation {
    /**
     * The CIDR range that was generated.
     * @example
     * 10.0.0.0/16
     */
    cidrBlock: string;
    /**
     * The seed used to generate this CIDR block.
     */
    seed: string;
    /**
     * The IP prefix of the CIDR range (IPv4 address of the start of the range).
     * @example
     * 10.0.0.0
     */
    prefix: string;
    /**
     * The network mask of the CIDR range (integer representing the range of the CIDR block).
     * @example
     * 16
     */
    networkMask: number;
}
/**
 * Arguments for generating a CIDR block.
 */
interface AllocateCidrBlockArguments {
    /**
     * A string to be used as a seed for the CIDR generation.
     *
     * @remarks
     * If all other inputs are the same, two different seeds have a 1 in 256 chance of being duplicates.
     * If you are generating multiple CIDR blocks and need them to be unique, generate them in sequence providing previously generated blocks in the {@link exclusions} argument.
     */
    seed: string;
    /**
     * An IPv4 prefix for the CIDR block to use as a base.
     *
     * @remarks
     * Depending on the network mask, one of the octets will likely be replaced.
     * This should typically be from the Private Address Space defined in RFC 1918 {@link http://www.faqs.org/rfcs/rfc1918.html}
     *
     * @defaultValue 10.0.0.0
     */
    prefix?: string;
    /**
     * An integer between 8 and 32
     *
     * @remarks
     * This value will determine how many IP addresses are available within your CIDR block.
     *
     * @defaultValue 16
     */
    networkMask?: number;
    /**
     * CIDR blocks that should be excluded from the results.
     *
     * @remarks
     * If the CIDR block generated matches any of the values provided here, the method will re-generate and re-check against this list until it runs out of options.
     * Note that for a given prefix and network mask, only 256 unique CIDR blocks can be generated.
     */
    exclusions?: string[];
}
/**
 * Deterministically generate a CIDR block range.
 *
 * @remarks
 * Given the same inputs, it will generate the same output.
 * This can be useful if you need to create mutiple VPCs that need to be peered since peered VPCs cannot have overlapping CIDR ranges.
 *
 * @param args - {@link AllocateCidrBlockArguments}
 * @returns CidrBlockAllocation - {@link CidrBlockAllocation}
 */
declare function allocateCidrBlock(args: AllocateCidrBlockArguments): CidrBlockAllocation;
export { allocateCidrBlock, CidrBlockAllocation };
